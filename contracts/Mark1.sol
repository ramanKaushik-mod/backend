// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract Mark1 {
    string[] public gPIDs;

    function getGPIDsLength() public view returns (uint256) {
        return gPIDs.length;
    }

    function getGPIDS() public view returns (string[] memory){
        return gPIDs;
    }

    // used for checking repeatations of emails used by creators
    mapping(string => bool) public pCEmails;
    // used for checking repeatations of emails used by creators
    mapping(string => bool) public vEmails;
    // mapping ( _email => mapping(_password => Creator)) public creators;
    mapping(string => mapping(string => Creator)) public creators;
    // mapping( _email => _passcode) ep;
    mapping(string => string) ep;
    // mapping ( _email => _passcode) vep;
    mapping(string => string) vep;
    
    // mapping (_id => _email)
    mapping (string => string) validateCreatorIDEmail;   
    
    // mapping (_id => _email)
    mapping (string => string) validateVoterIDEmail;

    // mapping ( _pollId => pMembersCount ) public pollMembersCount
    mapping(string => uint256) public PMC;

    function setPMC(string memory _pid, uint256 _pmc) public {
        PMC[_pid] = _pmc;
    }

    struct Creator {
        string pCName;
        string pCEmail; 
        string pCContact;
        string person;
        string id;
    }

    function addCreator(
        string memory _password,
        string memory _name,
        string memory _email,
        string memory _contact,
        string memory _id
    ) public {
        creators[_email][_password] = Creator(
            _name,
            _email,
            _contact,
            "creator", 
            _id
        );
        pCEmails[_email] = true;
        ep[_email] = _password;
        validateCreatorIDEmail[_id] = _email;
    }

    mapping(string => string[]) public pIDs;
    
    function getpIDsLength(
        string memory _email
    ) public view returns (uint256) {
        return pIDs[_email].length;
    }
    struct Poll {
        string pollId;
        string title;
        string createdAt;
        string startdate;
        string enddate;
    }

    mapping(string => Poll) public pollData;

    function addPIDs(
        string memory _email,
        string memory _pID,
        string memory createdAt,
        string memory startDate,
        string memory endDate,
        string memory title
    ) public {
        pIDs[_email].push(_pID); // local to the Creator
        pollData[_pID] = Poll(
            _pID,
            title,
            createdAt,
            startDate,
            endDate
        );
        gPIDs.push(_pID); // global to everyone
    }

    function updateCPasscode(string memory _email, string memory _newPasscode)
        public
    {
        Creator memory c = creators[_email][ep[_email]];
        delete (creators[_email][ep[_email]]);
        creators[_email][_newPasscode] = c;
        delete (ep[_email]);
        ep[_email] = _newPasscode;
    }

    function validateCreator(
        string memory _email,
        string memory _id
    ) public view returns(bool){
        if(keccak256(bytes(validateCreatorIDEmail[_id])) == keccak256(bytes(_email))){
            return true;
        }else{
            return false;
        }
    }

    // mapping (_pollId => Candidate[]) public candidates;
    mapping(string => Candidate[]) public candidates;

    function getCLength(
        string memory _pID
    )view public returns(uint256){
        uint256 cLength = candidates[_pID].length;
        return cLength;
    }

    // mapping (_pollId => mapping( candidateId => voteCount)) public candidateVoteCount;
    mapping(string => mapping(string => uint256)) public candidateVoteCount;

    struct Candidate {
        string cName;
        string cManifesto;
        string cID;
    }

    function addCandidate(
        string memory _pollId, // generated by back-end
        string memory _name,
        string memory _manifesto,
        string memory _candidateId // generated by back-end
    ) public {
        candidates[_pollId].push(Candidate(_name, _manifesto, _candidateId));
        candidateVoteCount[_pollId][_candidateId] = 0; // needs to watch for live changes
    }

    function getCandidates(
        string memory _pollId
    ) public view returns (Candidate[] memory){
        return candidates[_pollId];
    }

    // mapping (voterId => mapping (pollId => voteFlag)) vote;
    mapping(string => mapping(string => bool)) public vote;

    function voting(
        string memory _pID,
        string memory _candidateId,
        string memory _voterId
    ) public {
        ++candidateVoteCount[_pID][_candidateId];
        if(vote[_voterId][_pID] == false){
            vote[_voterId][_pID] = true;
        }
    }

    // accessing voter using password
    // mapping (voterId => mapping(password => Voter)) public voters;
    mapping(string => mapping(string => Voter)) public voters;

    struct Voter {
        string voterName;
        string voterContactNo;
        string voterId; // for changing password or checking vote status
        string person;
        string id;
    }

    function addVoter(
        string memory _password,
        string memory _voterName,
        string memory _voterContactNo,
        string memory _voterId,
        string memory _id
    ) public {
        voters[_voterId][_password] = Voter(
            _voterName,
            _voterContactNo,
            _voterId,
            "voter",
            _id
        ); // voter added to voters mapping
        vEmails[_voterId] = true;
        vep[_voterId] = _password;
        validateVoterIDEmail[_id] = _voterId;
    }

    function updateVPasscode(string memory _email, string memory _newPasscode)
        public
    {
        Voter memory v = voters[_email][vep[_email]];
        delete (voters[_email][ep[_email]]);
        voters[_email][_newPasscode] = v;
        delete (vep[_email]);
        vep[_email] = _newPasscode;
    }

    function validateVoter(
        string memory _email,
        string memory _id
    ) public view returns(bool){
        if(keccak256(bytes(validateVoterIDEmail[_id])) == keccak256(bytes(_email))){
            return true;
        }else{
            return false;
        }
    }

    mapping(string => string[]) public vPIDs;

    function addVIDs(
        string memory _voterId,
        string memory _pID // provided by the creator to the voters
    ) public {
        vPIDs[_voterId].push(_pID);
        vote[_voterId][_pID] = false;
    }

    function getVPIDs(
        string memory _voterId
    )public view returns(string[] memory) {
        return vPIDs[_voterId];
    }

    function checkVoteStatus(
        string memory _voterId,
        string memory _pollId
    ) public view returns (bool)
    {
        if (vote[_voterId][_pollId] == true) {
            return true;
        } else {
            return false;
        }
    }

    // OPERATIONS
    function checkPid(
        string memory _pid
    )public view returns(bool){
        for(uint256 i = 0; i< gPIDs.length; i++){
            if(keccak256(bytes(gPIDs[i])) == keccak256(bytes(_pid))){
                return true;
            }
        }
        return false;
    }

    function checkPidInVIDs(
        string memory _voterId,
        string memory _pid
    )public view returns(bool){
        string[] memory arr = vPIDs[_voterId];
        for(uint256 i = 0; i< arr.length; i++){
            if(keccak256(bytes(arr[i] )) == keccak256(bytes(_pid))){
                return true;
            }
        }
        return false;
    }
}
